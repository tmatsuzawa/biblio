#!/usr/bin/env python

import argparse
import os
import time
import sys

import cine
import json
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import pickle
from matplotlib import cm
from numpy import *
from scipy import ndimage, interpolate
from mpl_toolkits.axes_grid1 import make_axes_locatable
#import ilpm.cine as cine
import numpy as np

sys.path.append('/Users/stephane/Documents/git/takumi/')
import library.tools.vectools as vec
import library.display.graph as graph


cmap = cm.bwr

cx_lim = 100
cy_lim = 100

threshold = .08

sw = 15
OUTDIR = '/Users/stephane/Documents/Takumi/Analysis_Results/'

def load_matlab_data(datapath):
    """Reads data from .txt files generated by PIVlab and places them into numpy arrays

    Parameters
    ----------
    data_loc : str
        The directory containing .txt files generated from PIVlab

    Returns
    -------
    x, y, ux, uy, omega array (floats)
        coordinates, velocity components, and vorticity calculated by PIVlab in easy to use numpy array format
    """
    file = open(datapath)
    x, y, ux, uy, omega = [], [], [], [], []
    for i, line in enumerate(file):
        if i < 3:
            continue
        for j, val in enumerate(line.split(',')):
            if j == 0:
                x.append(int(val))
            elif j == 1:
                y.append(int(val))
            elif j == 2:
                ux.append(float(val))
            elif j == 3:
                uy.append(float(val))
            elif j == 4:
                omega.append(float(val))

    if j==4:
        x, y, ux, uy, omega = map(lambda z: asarray(z), [x, y, ux, uy, omega])
        return x, y, ux, uy, omega
    elif j==3:
        x, y, ux, uy = map(lambda z: asarray(z), [x, y, ux, uy])
        return x, y, ux, uy


def interp_flow_component(x, y, ux, imsize, xint=1., yint=1., method='linear'):
    uxindicies = [(xx, yy) for xx, yy in zip(x, y)]
    #grid_ind0, grid_ind1 = mgrid[0:imsize[0], 0:imsize[1]]
    #griddata = interpolate.griddata(uxindicies, ux, (grid_ind0, grid_ind1), method=method, fill_value=0.)

    xnew, ynew = np.arange(x[0], x[-1] + xint, xint), np.arange(y[0], y[-1] + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    griddata = interpolate.griddata(uxindicies, ux, (Xnew, Ynew), method=method, fill_value=0.)

    # plt.subplot(111)
    # plt.imshow(griddata)
    # plt.show()
    return griddata

def interp_for_pcolormesh(x, y, data, xint=1., yint=1., method='cubic'):
    f = interpolate.interp2d(x, y, data, kind=method)

    # make a meshgrid
    xnew, ynew = np.arange(x[0], x[-1] + xint, xint), np.arange(y[0], y[-1] + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    # interpolate using scipy.interpolate.inter2d
    datanew = f(xnew, ynew)

    return Xnew, Ynew, datanew


def colorbar(mappable, location='right'):

    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(location, size='5%', pad=0.05)
    return fig.colorbar(mappable, cax=cax)


def weighted_mean(means, stds):
    """
    Compute weighted arithmetic mean
    Parameters
    ----------
    means : list (floats)
        list of mean values
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean : float
    """
    return sum(asarray(means * (1. / asarray(stds)))) / sum(1. / asarray(stds))


def weighted_mean_std(stds):
    """
    Compute the uncertainty for a weighted mean
    Parameters
    ----------
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean_std : float
    """
    return sqrt(1. / sum(1. / asarray(stds)))


if __name__ == '__main__':
    """
    Pass a absolute path of the cine files through '-input' e.g. -input '/absolute/path/to/cineDir/*.cine'
    """
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('-input', metavar='input', type=str, nargs='*', default=None, help='')
    parser.add_argument('-NP', dest='NP', type=int, default=800,
                        help='Number of points to sample along the circulation contour')
    parser.add_argument('-min_radius', dest='min_radius', type=float, default=10,
                        help='Smallest radius of circulation contour explored (pixels)')
    parser.add_argument('-max_radius', dest='max_radius', type=float, default=70,
                        help='Largest radius of circulation contour explored (pixels)')
    parser.add_argument('-sample_pts', dest='sample_pts', type=int, default=10,
                        help='number of points between min and max radius at which to sample the circulation')
    parser.add_argument('-cm_shift', dest='cm_shift', type=int, default=10,
                        help='Largest amount to shift the center of the circulation contour')

    parser.add_argument('-scale', dest='scale', type=float, default=None)
    parser.add_argument('-rate', dest='rate', type=float, default=None)
    parser.add_argument('-frame_spacing', dest='frame_spacing', type=float, default=1)
    parser.add_argument('-plot_spacing', dest='plot_spacing', type=int, default=1)

    parser.add_argument('-start', dest='start', type=int, default=0)
    parser.add_argument('-stop', dest='stop', type=int, default=0)
    parser.add_argument('-skip', dest='skip', type=int, default=10)

    parser.add_argument('-omegabool', dest='omegabool', default=True)


    parser.add_argument('--summarize', dest='summarize', action='store_true', default=False,
                        help='Plot only the aggregate data, assuming that the .json files have already been generated')
    parser.add_argument('--save_circ', dest='save_circ', action='store_true', default=False)


    # PARSE COMMAND LINE INPUTS
    args = parser.parse_args()

    cine_inputs = args.input
    NP = args.NP
    min_radius = args.min_radius
    max_radius = args.max_radius
    sample_pts = args.sample_pts
    cm_shift = args.cm_shift
    summarize = args.summarize
    save_circ = args.save_circ
    scale = args.scale
    rate = args.rate
    frame_spacing = args.frame_spacing
    plot_spacing = args.plot_spacing
    omegabool = args.omegabool

    # SETUP SOME VARIABLES FOR PLOTTING TO BE USED THROUGHOUT SCRIPT
    radii = linspace(min_radius, max_radius, num=sample_pts, endpoint=True)
    phi = arange(NP) * 2 * pi / float(NP)


    for cnum, cine_file in enumerate(cine_inputs):

        # LOAD CINE FILE AND GRAB IMAGE SIZE

        movie = cine.open(cine_file)
        imsize = shape(movie[0])

        box_size = 32

        # GENERATE FILE ARCHITECTURE
        date_dir, cine_name = os.path.split(cine_file)
        name, ext = os.path.splitext(cine_name)
        #cine_dir = os.path.join(date_dir, name)
        #resultsdir = date_dir + '/PIV_AnalysisResults/' + name #ABS PATH TO OUTPUT DIRECTORY
        resultsdir = '/Users/stephane/Documents/Takumi/Analysis_Results/'+ name

        print 'Working on Cine file: ', name

        # # CREATE A DIRECTORY TO STORE RESULTS
        # if not os.path.exists(resultsdir):
        #     os.makedirs(resultsdir)

        # CREATE A DIRECTORY TO STORE RESULTS OF CIRCULATION COMPUTATION
        circulation_dir = resultsdir + '/circulation/'
        if not os.path.exists(circulation_dir):
            os.makedirs(circulation_dir)

        # GRAB A DIRECTORY NAME WHERE PIVLAB-GENERATED txt FILES ARE STORED
        data_dir = date_dir + '/PIV_W%s_step%s_data' % (box_size, int(frame_spacing)) + \
                   '/PIVlab_ratio2_W%spix_Dt_%s_' % (box_size, int(frame_spacing)) + name

        print movie.len


        # CHECK IF DATA FILES(txt FILES GENERATED BY PIVLAB) EXIST
        if not os.path.exists(data_dir):
            print 'NO DATA DIRECTORY FOUND! EXITING'
            sys.exit()


        # INITIALIZE EMTPY LISTS FOR ROBUST GAMMA COMPUTATIONS
        robust_gammas = []
        robust_radii = []
        robust_frames = []
        robust_wav_gammas = []
        robust_wav_stds = []

        # ITERATE THROUGH FRAMES IN CINE FILE
        if args.stop == 0:
            frames = range(args.start, movie.__len__(), args.skip)
        else:
            frames = range(args.start, args.stop, args.skip)
        print 'Working on frame range: (%d:%d)' % (frames[0], frames[-1])

        for i, f in enumerate(frames):
            print 'image size: ', imsize
            if f - ((f/plot_spacing) * plot_spacing) == 0:
                print 'Processing frame %d' % f
                try:
                    i += frames[0] / frame_spacing
                except TypeError:
                    print 'NO FRAME SPACING SPECIFIED! EXITING'

                try:
                    #data_name = 'D%04d.txt' % (i + 1)
                    data_name = 'D%04d.txt' % f
                    print os.path.join(data_dir, data_name)

                    # Load velocity field data from the PIVLab data output
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, data_name))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, data_name))

                except IOError:
                    print 'NO DATA EXISTS FOR FRAME: %d; SKIPPING!' % f
                    continue

                print 'Loaded D%04d.txt' % f
                print len(omega)
                # COMPUTE INTERPOLATED VELOCITY
                try:
                    ix, iy = map(lambda pos: pos * scale , [x, y])
                    iux, iuy = map(lambda flow: flow * scale * rate, [ux, uy])
                except TypeError:
                    print 'ERROR: No input for scale, rate, or both'

                print 'ux_max', max(iux.flatten())
                #print len(ux), len(iux), len(uy), len(iuy)
                # COMPUTE VORTICITY USING THE INTERPOLATED VELOCITY FIELD
                #print iux, iuy
                iomega = map(lambda vort: vort * rate, omega)
                #iomega = interp_flow_component(x, y, omega * rate, imsize)

                # FIND CENTER OF VORTEX FROM WEIGHTED AVERAGE IN A BOX CENTERED ON THE MAXIMUM VALUE OF OMEGA
                # print 'max iomega: ', max(iomega.flatten())
                # print 'min iomega: ', min(iomega.flatten())
                # print 'max omega: ', max(omega.flatten())
                # print 'min omega: ', min(omega.flatten())
                # max_x, max_y = where(iomega == max(iomega.flatten()))
                # min_x, min_y = where(iomega == min(iomega.flatten()))
                # print 'max iomega postion: ' , (max_x[0], max_y[0])
                # print 'min iomega postion: ' , (min_x[0], min_y[0])
                # print 'max omega postion: ' , (max_xx[0], max_yy[0])
                # print 'min omega postion: ' , (min_xx[0], min_yy[0])



                #print omega
                print x.shape
                # Figure out the number of voxels (nx, ny)
                nx, ny = (x[-1]-x[0])*2/box_size + 1 , (y[-1]-y[0])*2/box_size + 1
                # Prepare a grid
                xphys, yphys = np.mgrid[slice(x[0], x[-1]+1, box_size/2), slice(y[0], y[-1]+1, box_size/2)]
                #print xphys, yphys
                # Reshape omega into nx x ny array
                omegagrid = np.array(omega).reshape((nx,ny))
                # omegagrid[:] = omegagrid[:] * rate
                # max_xx, max_yy = where(omegagrid == max(omegagrid.flatten()))
                # min_xx, min_yy = where(omegagrid == min(omegagrid.flatten()))
                #
                # print max(omegagrid.flatten()), min(omegagrid.flatten())

                #Plot
                #Method1-3 has issues with the axes. Data should be rotated by 180, and -90 deg.
                #I should fix this in the near future. - Takumi 2/9/18
                w_limit = 300

                # #Method 1: pcolormesh
                # ## interpolation may be trickier than imshow
                # w_limit = maximum(max(omega.flatten()), abs(min(omega.flatten())))
                # graph.color_plot(xphys, yphys, omegagrid * rate, vmin=-w_limit, vmax=w_limit, cmap=cmap,fignum=1)
                # graph.colorbar()
                # graph.title('pcolormesh- no interpolation', fignum=1)
                #
                #
                # ##Method 2 pcolormesh + interpolation (use x4 more data points)
                # # interpolate data using scipy.interpolate.interp2d()
                # Xnew, Ynew, omeganew = interp_for_pcolormesh(x, y, omega * rate, xint=16., yint=16.)
                # w_limit = 400
                # graph.color_plot(Xnew, Ynew, omeganew, vmin=-w_limit, vmax=w_limit, cmap=cmap, fignum=2)
                # graph.colorbar(fignum=2)
                # graph.title('pcolormesh- linear interpolation', fignum=2)
                #
                # #Method 3:imshow (raw data)
                # ## Various interpolation methods are available
                # graph.imshow(omegagrid * rate, xmin=x.min(), xmax=x.max(), ymin=y.min(), ymax=y.max(), interpolation='gaussian',\
                #              cmap=cmap,vmin=-w_limit,vmax=w_limit, fignum=3)
                # graph.title('imshow (raw data)' , fignum=3)

                #Method 4: imshow + interpolation on griddata using interpolate.griddata
                iomegagrid = interp_flow_component(x, y, omega * rate, imsize)
                fig, ax, cax, cc = graph.imshow(iomegagrid, xmin=x.min(), xmax=x.max(), ymin=y.min(), ymax=y.max(), interpolation='gaussian',\
                             cmap=cmap,vmin=-w_limit,vmax=w_limit, fignum=4, cbar=True)
                graph.title('imshow + interpolation- gaussian', fignum=4)
                cc.set_label('$\omega_z [1/s]$')








                fig_name = 'circulation_%06d.png' % f
                fig_file = os.path.join(circulation_dir, fig_name)
                plt.savefig(fig_file)
                plt.close()
                #graph.show()




    print 'Done'