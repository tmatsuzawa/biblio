#!/usr/bin/env python

import argparse
import os
import time
import sys

import cine
import json
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import pickle
from matplotlib import cm
from numpy import *
from scipy import ndimage, interpolate
from mpl_toolkits.axes_grid1 import make_axes_locatable


cmap = cm.spectral

cx_lim = 100
cy_lim = 100

threshold = .08

sw = 15
OUTDIR = '/Users/stephane/Documents/Takumi/Analysis_Results/'


def load_matlab_data(data_loc):
    """Reads data from .txt files generated by PIVlab and places them into numpy arrays

    Parameters
    ----------
    data_loc : str
        The directory containing .txt files generated from PIVlab

    Returns
    -------
    x, y, ux, uy, omega array (floats)
        coordinates, velocity components, and vorticity calculated by PIVlab in easy to use numpy array format
    """
    fyle = open(data_loc)
    x, y, ux, uy, omega = [], [], [], [], []
    for i, line in enumerate(fyle):
        if i < 3:
            continue
        for j, val in enumerate(line.split(',')):
            if j == 0:
                x.append(int(val))
            elif j == 1:
                y.append(int(val))
            elif j == 2:
                ux.append(float(val))
            elif j == 3:
                uy.append(float(val))
            elif j == 4:
                omega.append(float(val))
    x, y, ux, uy, omega = [asarray(z) for z in [x, y, ux, uy, omega]]
    return x, y, ux, uy, omega


def interp_flow_component(x, y, ux, imsize):
    uxindicies = [(yy, xx) for xx, yy in zip(x, y)]
    grid_ind0, grid_ind1 = mgrid[0:imsize[0], 0:imsize[1]]
    return interpolate.griddata(uxindicies, ux, (grid_ind0, grid_ind1), method='cubic', fill_value=0.)


def colorbar(mappable, location='right'):
    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(location, size='5%', pad=0.05)
    return fig.colorbar(mappable, cax=cax)


def weighted_mean(means, stds):
    """
    Compute weighted arithmetic mean
    Parameters
    ----------
    means : list (floats)
        list of mean values
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean : float
    """
    return sum(asarray(means * (1. / asarray(stds)))) / sum(1. / asarray(stds))


def weighted_mean_std(stds):
    """
    Compute the uncertainty for a weighted mean
    Parameters
    ----------
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean_std : float
    """
    return sqrt(1. / sum(1. / asarray(stds)))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('input', metavar='input', type=str, nargs='*', default=None, help='')
    parser.add_argument('-NP', dest='NP', type=int, default=800,
                        help='Number of points to sample along the circulation contour')
    parser.add_argument('-min_radius', dest='min_radius', type=float, default=50,
                        help='Smallest radius of circulation contour explored (pixels)')
    parser.add_argument('-max_radius', dest='max_radius', type=float, default=200,
                        help='Largest radius of circulation contour explored (pixels)')
    parser.add_argument('-sample_pts', dest='sample_pts', type=int, default=10,
                        help='number of points between min and max radius at which to sample the circulation')
    parser.add_argument('-cm_shift', dest='cm_shift', type=int, default=10,
                        help='Largest amount to shift the center of the circulation contour')

    parser.add_argument('-scale', dest='scale', type=float, default=None)
    parser.add_argument('-rate', dest='rate', type=float, default=None)
    parser.add_argument('-frame_spacing', dest='frame_spacing', type=float, default=None)
    parser.add_argument('-plot_spacing', dest='plot_spacing', type=int, default=1)

    parser.add_argument('-start', dest='start', type=int, default=0)
    parser.add_argument('-stop', dest='stop', type=int, default=0)
    parser.add_argument('-skip', dest='skip', type=int, default=10)

    parser.add_argument('--summarize', dest='summarize', action='store_true', default=False,
                        help='Plot only the aggregate data, assuming that the .json files have already been generated')
    parser.add_argument('--save_circ', dest='save_circ', action='store_true', default=False)

    # PARSE COMMAND LINE INPUTS
    args = parser.parse_args()

    cine_inputs = args.input
    NP = args.NP
    min_radius = args.min_radius
    max_radius = args.max_radius
    sample_pts = args.sample_pts
    cm_shift = args.cm_shift
    summarize = args.summarize
    save_circ = args.save_circ
    scale = args.scale
    rate = args.rate
    frame_spacing = args.frame_spacing
    plot_spacing = args.plot_spacing

    # SETUP SOME VARIABLES FOR PLOTTING TO BE USED THROUGHOUT SCRIPT
    radii = linspace(min_radius, max_radius, num=sample_pts, endpoint=True)
    phi = arange(NP) * 2 * pi / float(NP)

    # ITERATE THROUGH INPUT CINE FILES
    for cnum, cine_file in enumerate(cine_inputs):

        # LOAD CINE FILE AND GRAB IMAGE SIZE
        if os.path.isdir(cine_file):
            imsize = (800, 1200)
        else:
            movie = cine.open(cine_file)
            imsize = shape(movie[0])

        box_size = 64
        # GENERATE FILE ARCHITECTURE
        date_dir, cine_name = os.path.split(cine_file)
        name, ext = os.path.splitext(cine_name)
        cine_dir = os.path.join(date_dir, name)

        print('Working on Cine file: ', name)
        if not os.path.exists(cine_dir):
            os.mkdir(cine_dir)

        data_dir = os.path.join(cine_dir, 'tif_data', 'PIV_W%s_step%s_data' % (box_size, int(frame_spacing)))
        print(data_dir)
        circulation_dir = os.path.join(OUTDIR, name + '_W' + str(box_size))
        if not os.path.exists(circulation_dir):
            os.mkdir(circulation_dir)
        if not os.path.exists(data_dir):
            print('NO DATA DIRECTORY FOUND! EXITING')
            sys.exit()

        # INITIALIZE EMTPY LISTS FOR ROBUST GAMMA COMPUTATIONS
        robust_gammas = []
        robust_radii = []
        robust_frames = []
        robust_wav_gammas = []
        robust_wav_stds = []

        # ITERATE THROUGH FRAMES IN CINE FILE
        if args.stop == 0:
            frames = list(range(args.start, 11000, args.skip))
        else:
            frames = list(range(args.start, args.stop, args.skip))
        print('Working on frame range: (%d:%d)' % (frames[0], frames[-1]))


        for i, f in enumerate(frames):
            if f - ((f/plot_spacing) * plot_spacing) == 0:
                print('Processing frame %d' % f)
                try:
                    i += frames[0] / frame_spacing
                except TypeError:
                    print('NO FRAME SPACING SPECIFIED! EXITING')

                if not summarize:

                    # LOAD PIVlab DATA
                    try:
                        data_name = 'PIVlab_%04d.txt' % (i + 1)
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, data_name))

                    except IOError:
                        print('NO DATA EXISTS FOR FRAME: %d; SKIPPING!' % f)
                        continue

                    print('Loaded PIVlab_%d.txt' % (i + 1))
                    # COMPUTE INTERPOLATED VELOCITY AND VORTICITY FIELDS
                    iux, iuy = [interp_flow_component(x, y, flow * scale * rate, imsize) for flow in [ux, uy]]
                    iomega = interp_flow_component(x, y, omega * rate, imsize)

                    # FIND CENTER OF VORTEX FROM WEIGHTED AVERAGE IN A BOX CENTERED ON THE MAXIMUM VALUE OF OMEGA
                    rad = int(16 / scale)
                    max_x_arr, max_y_arr = where(iomega == iomega.max())
                    if not max_x_arr:
                        continue

                    max_x, max_y = [int(x[0]) for x in [max_x_arr, max_y_arr]]
                    w_cy, w_cx = ndimage.measurements.center_of_mass(
                        iomega[max_y - rad:max_y + rad, max_x - rad:max_x + rad])
                    cy = w_cy + (max_y - rad)
                    cx = w_cx + (max_x - rad)

                    # CONFIRM VORTEX CENTER IS IN FRAME
                    if isnan(cx):
                        print('VORTEX NOT IN FRAME, SKIPPING')
                        continue

                    # CONFIRM THAT CIRCULATION CURVES ARE ALL IN THE FRAME
                    bad_y_path = False
                    path_y_limits = radii[-1] * sin(phi) + cy
                    cutoff = (box_size/2) + 1
                    if (path_y_limits <= cutoff).any() or (path_y_limits >= (imsize[0] - cutoff)).any():
                        bad_y_path = True
                    if bad_y_path:
                        print('CIRCULATION CURVE NOT IN FRAME, SKIPPING')
                        continue

                    bad_x_path = False
                    path_x_limits = radii[-1] * cos(phi) + cx
                    if (path_x_limits <= cutoff).any() or (path_x_limits >= (imsize[1] - cutoff)).any():
                        bad_x_path = True
                    if bad_x_path:
                        print('CIRCULATION CURVE NOT IN FRAME, SKIPPING')
                        continue

                    # GENERATE SUBFIGURES OF INTERPOLATED QUANTITIES
                    fig = plt.figure(figsize=(12, 12))
                    gs = gridspec.GridSpec(3, 3, width_ratios=[1, 1, 1], height_ratios=[1.5, 1, 2])

                    # iUx Plot
                    img1 = fig.add_subplot(gs[0])
                    x_limit = maximum(abs(amax(iux)), abs(amin(iux)))
                    ax1 = img1.imshow(iux, cmap='RdBu', vmin=-x_limit, vmax=x_limit)
                    colorbar(ax1)
                    for r in radii:
                        img1.plot(r * cos(phi) + cx, r * sin(phi) + cy, color=cmap(float(r) / float(max(radii))))

                    # iUy Plot
                    img2 = fig.add_subplot(gs[1])
                    y_limit = maximum(abs(amax(iuy)), abs(amin(iuy)))
                    ax2 = img2.imshow(iuy, cmap='RdBu', vmin=-y_limit, vmax=y_limit)
                    colorbar(ax2)
                    for r in radii:
                        img2.plot(r * cos(phi) + cx, r * sin(phi) + cy, color=cmap(float(r) / float(max(radii))))

                    # iOmega Plot
                    img3 = fig.add_subplot(gs[2])
                    w_limit = maximum(abs(amax(iomega)), abs(amin(iomega)))
                    ax3 = img3.imshow(iomega, vmin=-w_limit, vmax=w_limit)
                    colorbar(ax3)
                    for r in radii:
                        img3.plot(r * cos(phi) + cx, r * sin(phi) + cy, color=cmap(float(r) / float(max(radii))))

                    imgs = [img1, img2, img3]
                    titles = ['$u_x$ velocity $(mm/s)$', '$u_y$ velocity $(mm/s)$', '$|\omega|$ $(1/s)$']
                    for img, text in zip(imgs, titles):
                        img.set_xlim([x[0], imsize[1] - x[0]])
                        img.set_ylim([y[0], imsize[0] - y[0]])
                        img.set_xticks([])
                        img.set_yticks([])
                        img.set_title(text)

                    # CALCULATE AND PLOT VELOCITY ALONG CIRCULATION CURVES
                    ax4 = plt.subplot(gs[3])
                    ax5 = plt.subplot(gs[4])
                    ax6 = plt.subplot(gs[5])
                    ax4.set_ylabel('velocity $(mm/s)$')

                    mean_gs = []
                    std_gs = []
                    for r in radii:
                        path_x, path_y = r * cos(phi) + cx, r * sin(phi) + cy
                        iux_p = ndimage.map_coordinates(iux, (path_y, path_x), order=1)
                        iuy_p = ndimage.map_coordinates(iuy, (path_y, path_x), order=1)

                        ax4.plot(phi, iux_p, color=cmap(float(r) / float(max(radii))))
                        ax5.plot(phi, iuy_p, color=cmap(float(r) / float(max(radii))))
                        ax6.plot(phi, -iux_p * sin(phi) + iuy_p * cos(phi), color=cmap(float(r) / float(max(radii))))

                        # CALCULATE AND PLOT CIRCULATIONS AND STATISTICS
                        gammas = []
                        ax7 = plt.subplot(gs[6:])
                        for off_i in range(-cm_shift, cm_shift + 1, 10):
                            for off_j in range(-cm_shift, cm_shift + 1, 10):
                                ds = 2 * pi * r / float(NP) * scale
                                path_x, path_y = r * cos(phi) + cx + off_i, r * sin(phi) + cy + off_j
                                iux_p = ndimage.map_coordinates(iux, (path_y, path_x), order=1)
                                iuy_p = ndimage.map_coordinates(iuy, (path_y, path_x), order=1)
                                gammas.append(sum((-iux_p * sin(phi) + iuy_p * cos(phi)) * ds))

                        mean_g = mean(asarray(gammas))
                        mean_gs.append(mean_g)
                        std_g = std(asarray(gammas))
                        std_gs.append(std_g)

                        ax7.scatter(r * scale, mean_g, color=cmap(float(r) / float(max(radii))), marker='o')
                        ax7.errorbar(r * scale, mean_g, yerr=std_g, ecolor=cmap(float(r) / float(max(radii))), elinewidth=2)

                    axs = [ax4, ax5, ax6]
                    titles = ['$u_x$', '$u_y$', r'$u_\theta$']
                    for ax, text in zip(axs, titles):
                        ax.set_title(text)
                        ax.set_xlim([0, 2 * pi])
                        ax.set_ylim([-500, 500])
                        ax.set_xticks((0, pi, 2 * pi))
                        ax.set_xticklabels(('$0$', '$\pi$', '$2\pi$'))

                    # STORE ROBUST AND WEIGHTED AVERAGE CIRCULATION DATA
                    robust_g = mean_gs[argmin(asarray(std_gs))]
                    robust_r = radii[argmin(asarray(std_gs))]
                    weighted_avg = weighted_mean(mean_gs, std_gs)
                    weighted_avg_std = weighted_mean_std(std_gs)

                    ax7.plot([radii[0] * scale, radii[-1] * scale], [weighted_avg, weighted_avg], 'k--')
                    ax7.plot([radii[0] * scale, radii[-1] * scale], [robust_g, robust_g],
                             color=cmap(float(robust_r) / float(max(radii))))
                    ax7.set_ylim([0, 30000])
                    ax7.set_xlabel('countour radius $(mm)$')
                    ax7.set_ylabel('circulation $(mm^2/s)$')
                    ax7.set_title('time: %.4f' % (f / rate))

                    robust_gammas.append(robust_g)
                    robust_radii.append(robust_r)
                    robust_wav_gammas.append(weighted_avg)
                    robust_wav_stds.append(weighted_avg_std)
                    robust_frames.append(f)

                    # STORE CIRCULATION DATA IN JSON FORMAT AND SAVE PLOT
                    circulation_data = {'mean_gamma': list(mean_gs),
                                        'std_gamma': list(std_gs),
                                        'radii': list(radii),
                                        'weighted_avg': weighted_avg,
                                        'weighted_avg_std': weighted_avg_std}

                    circulation_data_name = 'circulation_data_%06d.json' % f
                    circulation_data_file = os.path.join(circulation_dir, circulation_data_name)
                    with open(circulation_data_file, 'w') as fyle:
                        json.dump(circulation_data, fyle, sort_keys=True, indent=1, separators=(',', ': '))
                        fyle.close()

                    fig_name = 'circulation_%06d.png' % f
                    fig_file = os.path.join(circulation_dir, fig_name)
                    plt.savefig(fig_file)
                    plt.close()

            elif summarize and f - ((f/plot_spacing) * plot_spacing) == 0:
                circulation_data_name = 'circulation_data_%06d.json' % f
                circulation_data_file = os.path.join(circulation_dir, circulation_data_name)
                try:
                    circulation_data = json.load(open(circulation_data_file))
                except IOError:
                    print('No data found for %s!' % circulation_data_name)
                    continue

                robust_gammas.append(circulation_data['mean_gamma'][where(
                    asarray(circulation_data['std_gamma']) == min(circulation_data['std_gamma']))[0]])
                robust_radii.append(circulation_data['radii'][where(
                    asarray(circulation_data['std_gamma']) == min(circulation_data['std_gamma']))[0]])
                robust_wav_gammas.append(circulation_data['weighted_avg'])
                robust_wav_stds.append(circulation_data['weighted_avg_std'])
                robust_frames.append(f)

        # PLOT AGGREGATE DATA COMPRISED OF ALL PROCESSED FRAMES
        print('Working on aggregate plot')
        plt.figure(figsize=(8, 8))
        plt.subplot(211)

        # EXTRACT (FRAMES, ROBUST CIRCULATION, ROBUST RADII) THAT FALL WITHIN ONE SIGMA OF ROBUST CIRCULATIONS' MEAN
        mean_gamma = mean(robust_gammas)
        std_on_robust = std(robust_gammas)
        culled_gammas = [(f, gamma, r) for f, gamma, r in zip(robust_frames, robust_gammas, robust_radii) if
                         abs(gamma - mean_gamma) < std_on_robust]
        culled_mean = mean(asarray(culled_gammas)[:, 1])

        # SCATTER THE ROBUST DATA AS CIRCLES WHOSE COLOR CORRESPOND TO THE ROBUST RADII
        plt.scatter(robust_frames, robust_gammas,
                    edgecolors=cmap(asarray(robust_radii, dtype=float) / float(max_radius)), facecolors='none', s=40,
                    zorder=1)

        # SCATTER THE CULLED ROBUST DATA AS DOTS WHOSE COLOR CORRESPOND TO THE ROBUST RADII
        plt.scatter(asarray(culled_gammas)[:, 0], asarray(culled_gammas)[:, 1],
                    color=cmap(asarray(culled_gammas)[:, 2] / float(max_radius)), s=30, zorder=1)

        # EXTRACT (FRAMES, WEIGHTED AVG CIRCULATION, ROBUST RADII) THAT FALL WITHIN ONE SIGMA OF WEIGHTED AVG
        # CIRCULATIONS' MEAN
        culled_wav_gammas = [(f, gamma, r, sg) for f, gamma, r, sg in
                             zip(robust_frames, robust_wav_gammas, robust_radii, robust_wav_stds) if
                             abs(sg - mean(robust_wav_stds)) < (std(robust_wav_stds))]

        # PLOT THE MEAN OF THE ROBUST CIRCULATIONS, MEAN OF THE CULLED ROBUST CIRCULATIONS, AND MEAN OF THE WEIGHTED
        # AVERAGE CIRCULATIONS UNDERNEATH THE SCATTER PLOT ABOVE
        plt.plot([robust_frames[0], robust_frames[-1]], [mean_gamma, mean_gamma], 'r--', zorder=2)
        plt.plot([robust_frames[0], robust_frames[-1]], [culled_mean, culled_mean], 'g--', zorder=2)
        plt.plot([robust_frames[0], robust_frames[-1]], [mean(robust_wav_gammas), mean(robust_wav_gammas)], 'w--',
                 zorder=2)
        plt.annotate('mean Gamma: %0.4f' % culled_mean, xy=(robust_frames[0] + 20, 0.035))
        # plt.title(args.frames)
        # plt.colorbar()
        plt.ylim([5000, 30000])
        plt.xlim([robust_frames[0] - 100, robust_frames[-1] + 100])
        times = linspace(robust_frames[0] - 100, robust_frames[-1], 8)
        plt.xticks(times, [str(format(t, '.3f')) for t in (times - robust_frames[0]) / rate])
        plt.ylabel('circulation $(mm^2/s)$')
        plt.xlabel('time elapsed (sec)')

        # PLOT WEIGHTED AVERAGE ASSOCIATED TO THE ABOVE SUBPLOT
        plt.subplot(212)
        plt.errorbar(robust_frames, robust_wav_gammas, yerr=robust_wav_stds, color='k', marker='D', zorder=0, alpha=0.5)
        plt.errorbar(asarray(culled_wav_gammas)[:, 0], asarray(culled_wav_gammas)[:, 1],
                     yerr=asarray(culled_wav_gammas)[:, 3], color='g', marker='D', zorder=1, alpha=0.8)

        plt.plot([robust_frames[0], robust_frames[-1]], [mean_gamma, mean_gamma], 'r--', zorder=2)
        plt.plot([robust_frames[0], robust_frames[-1]], [culled_mean, culled_mean], 'g--', zorder=2)
        plt.plot([robust_frames[0], robust_frames[-1]], [mean(robust_wav_gammas), mean(robust_wav_gammas)], 'w--',
                 zorder=2)
        plt.ylim([5000, 30000])
        plt.xlim([robust_frames[0] - 100, robust_frames[-1] + 100])
        times = linspace(robust_frames[0] - 100, robust_frames[-1], 8)
        plt.xticks(times, [str(format(t, '.3f')) for t in (times - robust_frames[0]) / rate])
        plt.ylabel('circulation $(mm^2/s)$')
        plt.xlabel('time elapsed (sec)')
        # plt.annotate('mean Gamma: %0.4f'%(culled_mean),xy=(robust_frames[0]+20, 0.015))
        plt.annotate('weighted mean Gamma: %d' % int((mean(robust_wav_gammas))), xy=(0, 6000))

        # SAVE DATA, IF SPECIFIED
        if save_circ:
            circulation_pickle = os.path.join(circulation_dir, 'circulation.pickle')
            pickle.dump({'mean Gamma': culled_mean, 'wean Gamma': mean(asarray(culled_wav_gammas)[:, 1]),
                         'std': std(asarray(culled_gammas)[:, 1]), 'wstd': std(asarray(culled_wav_gammas)[:, 1])},
                        open(circulation_pickle, 'w'))

        # SAVE FIGURE
        fig_name = '0_circulation_collected_%s.png' % (str(args.start) + ":" + str(args.stop))
        fig_file = os.path.join(circulation_dir, fig_name)
        plt.suptitle(r'rate: %d $fps$, scale: %.3f $(mm/px)$' % (rate, scale))
        plt.savefig(fig_file)
        plt.close()
