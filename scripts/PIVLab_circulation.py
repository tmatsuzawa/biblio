#!/usr/bin/env python

import argparse
import os
import time
import sys

import cine
import json
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import pickle
from matplotlib import cm
from numpy import *
from scipy import ndimage, interpolate
from mpl_toolkits.axes_grid1 import make_axes_locatable
#import ilpm.cine as cine
import numpy as np

sys.path.append('/Users/stephane/Documents/git/takumi/')
import library.tools.vectools as vec

cmap = cm.spectral

cx_lim = 100
cy_lim = 100

threshold = .08

sw = 15
OUTDIR = '/Users/stephane/Documents/Takumi/Analysis_Results/'

def load_matlab_data(datapath):
    """Reads data from .txt files generated by PIVlab and places them into numpy arrays

    Parameters
    ----------
    data_loc : str
        The directory containing .txt files generated from PIVlab

    Returns
    -------
    x, y, ux, uy, omega array (floats)
        coordinates, velocity components, and vorticity calculated by PIVlab in easy to use numpy array format
    """
    file = open(datapath)
    x, y, ux, uy, omega = [], [], [], [], []
    for i, line in enumerate(file):
        if i < 3:
            continue
        for j, val in enumerate(line.split(',')):
            if j == 0:
                x.append(int(val))
            elif j == 1:
                y.append(int(val))
            elif j == 2:
                ux.append(float(val))
            elif j == 3:
                uy.append(float(val))
            elif j == 4:
                omega.append(float(val))

    if j==4:
        x, y, ux, uy, omega = map(lambda z: asarray(z), [x, y, ux, uy, omega])
        return x, y, ux, uy, omega
    elif j==3:
        x, y, ux, uy = map(lambda z: asarray(z), [x, y, ux, uy])
        return x, y, ux, uy


def interp_flow_component(x, y, ux, imsize):
    uxindicies = [(xx, yy) for xx, yy in zip(x, y)]
    grid_ind0, grid_ind1 = mgrid[0:imsize[0], 0:imsize[1]]

    griddata = interpolate.griddata(uxindicies, ux, (grid_ind0, grid_ind1), method='linear', fill_value=0.)

    # plt.subplot(111)
    # plt.imshow(griddata)
    # plt.show()
    return griddata


def colorbar(mappable, location='right'):

    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(location, size='5%', pad=0.05)
    return fig.colorbar(mappable, cax=cax)


def weighted_mean(means, stds):
    """
    Compute weighted arithmetic mean
    Parameters
    ----------
    means : list (floats)
        list of mean values
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean : float
    """
    return sum(asarray(means * (1. / asarray(stds)))) / sum(1. / asarray(stds))


def weighted_mean_std(stds):
    """
    Compute the uncertainty for a weighted mean
    Parameters
    ----------
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean_std : float
    """
    return sqrt(1. / sum(1. / asarray(stds)))


if __name__ == '__main__':
    """
    Pass a absolute path of the cine files through '-input' e.g. -input '/absolute/path/to/cineDir/*.cine'
    """
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('-input', metavar='input', type=str, nargs='*', default=None, help='')
    parser.add_argument('-NP', dest='NP', type=int, default=800,
                        help='Number of points to sample along the circulation contour')
    parser.add_argument('-min_radius', dest='min_radius', type=float, default=10,
                        help='Smallest radius of circulation contour explored (pixels)')
    parser.add_argument('-max_radius', dest='max_radius', type=float, default=70,
                        help='Largest radius of circulation contour explored (pixels)')
    parser.add_argument('-sample_pts', dest='sample_pts', type=int, default=10,
                        help='number of points between min and max radius at which to sample the circulation')
    parser.add_argument('-cm_shift', dest='cm_shift', type=int, default=10,
                        help='Largest amount to shift the center of the circulation contour')

    parser.add_argument('-scale', dest='scale', type=float, default=None)
    parser.add_argument('-rate', dest='rate', type=float, default=None)
    parser.add_argument('-frame_spacing', dest='frame_spacing', type=float, default=1)
    parser.add_argument('-plot_spacing', dest='plot_spacing', type=int, default=1)

    parser.add_argument('-start', dest='start', type=int, default=0)
    parser.add_argument('-stop', dest='stop', type=int, default=0)
    parser.add_argument('-skip', dest='skip', type=int, default=10)

    parser.add_argument('-omegabool', dest='omegabool', default=True)


    parser.add_argument('--summarize', dest='summarize', action='store_true', default=False,
                        help='Plot only the aggregate data, assuming that the .json files have already been generated')
    parser.add_argument('--save_circ', dest='save_circ', action='store_true', default=False)


    # PARSE COMMAND LINE INPUTS
    args = parser.parse_args()

    cine_inputs = args.input
    NP = args.NP
    min_radius = args.min_radius
    max_radius = args.max_radius
    sample_pts = args.sample_pts
    cm_shift = args.cm_shift
    summarize = args.summarize
    save_circ = args.save_circ
    scale = args.scale
    rate = args.rate
    frame_spacing = args.frame_spacing
    plot_spacing = args.plot_spacing
    omegabool = args.omegabool

    # SETUP SOME VARIABLES FOR PLOTTING TO BE USED THROUGHOUT SCRIPT
    radii = linspace(min_radius, max_radius, num=sample_pts, endpoint=True)
    phi = arange(NP) * 2 * pi / float(NP)


    for cnum, cine_file in enumerate(cine_inputs):

        # LOAD CINE FILE AND GRAB IMAGE SIZE
        if os.path.isdir(cine_file):
            imsize = (800, 1200)
        else:
            movie = cine.open(cine_file)
            imsize = shape(movie[0])

        box_size = 32

        # GENERATE FILE ARCHITECTURE
        date_dir, cine_name = os.path.split(cine_file)
        name, ext = os.path.splitext(cine_name)
        #cine_dir = os.path.join(date_dir, name)
        #resultsdir = date_dir + '/PIV_AnalysisResults/' + name #ABS PATH TO OUTPUT DIRECTORY
        resultsdir = '/Users/stephane/Documents/Takumi/Analysis_Results/'+ name

        print 'Working on Cine file: ', name

        # # CREATE A DIRECTORY TO STORE RESULTS
        # if not os.path.exists(resultsdir):
        #     os.makedirs(resultsdir)

        # CREATE A DIRECTORY TO STORE RESULTS OF CIRCULATION COMPUTATION
        circulation_dir = resultsdir + '/circulation/'
        if not os.path.exists(circulation_dir):
            os.makedirs(circulation_dir)

        # GRAB A DIRECTORY NAME WHERE PIVLAB-GENERATED txt FILES ARE STORED
        data_dir = date_dir + '/PIV_W%s_step%s_data' % (box_size, int(frame_spacing)) + \
                   '/PIVlab_ratio2_W%spix_Dt_%s_' % (box_size, int(frame_spacing)) + name

        print movie.len


        # CHECK IF DATA FILES(txt FILES GENERATED BY PIVLAB) EXIST
        if not os.path.exists(data_dir):
            print 'NO DATA DIRECTORY FOUND! EXITING'
            sys.exit()


        # INITIALIZE EMTPY LISTS FOR ROBUST GAMMA COMPUTATIONS
        robust_gammas = []
        robust_radii = []
        robust_frames = []
        robust_wav_gammas = []
        robust_wav_stds = []

        # ITERATE THROUGH FRAMES IN CINE FILE
        if args.stop == 0:
            frames = range(args.start, movie.__len__(), args.skip)
        else:
            frames = range(args.start, args.stop, args.skip)
        print 'Working on frame range: (%d:%d)' % (frames[0], frames[-1])

        for i, f in enumerate(frames):
            print 'image size: ', imsize
            if f - ((f/plot_spacing) * plot_spacing) == 0:
                print 'Processing frame %d' % f
                try:
                    i += frames[0] / frame_spacing
                except TypeError:
                    print 'NO FRAME SPACING SPECIFIED! EXITING'

                try:
                    #data_name = 'D%04d.txt' % (i + 1)
                    data_name = 'D%04d.txt' % f
                    print os.path.join(data_dir, data_name)

                    # Load velocity field data from the PIVLab data output
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, data_name))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, data_name))

                except IOError:
                    print 'NO DATA EXISTS FOR FRAME: %d; SKIPPING!' % f
                    continue

                print 'Loaded D%04d.txt' % f
                print len(omega)
                # COMPUTE INTERPOLATED VELOCITY
                try:
                    iux, iuy = map(lambda flow: interp_flow_component(x, y, flow * scale * rate, imsize), [ux, uy])
                except TypeError:
                    print 'ERROR: No input for scale, rate, or both'

                print 'ux_max', max(iux.flatten())
                #print len(ux), len(iux), len(uy), len(iuy)
                # COMPUTE VORTICITY USING THE INTERPOLATED VELOCITY FIELD
                #print iux, iuy

                iomega = interp_flow_component(x, y, omega * rate, imsize)

                # FIND CENTER OF VORTEX FROM WEIGHTED AVERAGE IN A BOX CENTERED ON THE MAXIMUM VALUE OF OMEGA
                rad = int(16 / scale)
                max_x_arr, max_y_arr = where(iomega == iomega.max())
                print 'max iomega: ', max(iomega.flatten())
                print 'min iomega: ', min(iomega.flatten())
                print 'max omega: ', max(omega.flatten())
                print 'min omega: ', min(omega.flatten())
                max_x, max_y = where(iomega == max(iomega.flatten()))
                min_x, min_y = where(iomega == min(iomega.flatten()))
                max_xx, max_yy = where(iomega == max(iomega.flatten()))
                min_xx, min_yy = where(iomega == min(iomega.flatten()))
                print 'max iomega postion: ' , (max_x[0], max_y[0])
                print 'min iomega postion: ' , (min_x[0], min_y[0])
                print 'max omega postion: ' , (max_xx[0], max_yy[0])
                print 'min omega postion: ' , (min_xx[0], min_yy[0])


                # CONFIRM THAT CIRCULATION CURVES ARE ALL IN THE FRAME
                bad_x_path = False
                path_x_limits = radii[-1] * cos(phi) + max_x

                bad_y_path = False
                path_y_limits = radii[-1] * sin(phi) + max_y
                cutoff = (box_size / 2) + 1
                #print imsize[0], imsize[1]
                if (path_y_limits <= cutoff).any() or (path_y_limits >= (imsize[1] - cutoff)).any():
                    bad_y_path = True
                if (path_x_limits <= cutoff).any() or (path_x_limits >= (imsize[0] - cutoff)).any():
                    bad_x_path = True
                #print bad_x_path, bad_y_path
                if bad_x_path or bad_y_path:
                    print 'CIRCULATION CURVE NOT IN FRAME, SKIPPING'
                    continue

                # GENERATE SUBFIGURES OF INTERPOLATED QUANTITIES
                fig = plt.figure(figsize=(12, 12))
                gs = gridspec.GridSpec(3, 3, width_ratios=[1, 1, 1], height_ratios=[1.5, 1, 2])

                # iUx Plot
                img1 = fig.add_subplot(gs[0])
                #x_limit = maximum(abs(amax(iux)), abs(amin(iux)))
                x_limit = maximum( max(iux.flatten()), abs(min(iux.flatten())) )
                #print abs(amax(iux)), max(iux.flatten())

                ax1 = img1.imshow(iux, cmap='RdBu', vmin=-x_limit, vmax=x_limit)
                colorbar(ax1)
                for r in radii:
                    img1.plot(r * cos(phi) + max_x, r * sin(phi) + max_y, color=cmap(float(r) / float(max(radii))))

                # iUy Plot
                img2 = fig.add_subplot(gs[1])
                #y_limit = maximum(abs(amax(iuy)), abs(amin(iuy)))
                y_limit = maximum(max(iuy.flatten()), abs(min(iuy.flatten())))
                ax2 = img2.imshow(iuy, cmap='RdBu', vmin=-y_limit, vmax=y_limit)
                colorbar(ax2)
                for r in radii:
                    img2.plot(r * cos(phi) + max_x, r * sin(phi) + max_y, color=cmap(float(r) / float(max(radii))))

                # iOmega Plot
                img3 = fig.add_subplot(gs[2])
                #w_limit = maximum(abs(amax(iomega)), abs(amin(iomega)))
                w_limit = maximum(max(iomega.flatten()), abs(min(iomega.flatten())))
                print 'w_limit: ', w_limit
                ax3 = img3.imshow(iomega, vmin=-w_limit, vmax=w_limit)
                colorbar(ax3)
                #for r in radii:
                #    img3.plot(r * cos(phi) + max_x, r * sin(phi) + max_y, color=cmap(float(r) / float(max(radii))))

                imgs = [img1, img2, img3]
                titles = ['$u_x$ velocity $(mm/s)$', '$u_y$ velocity $(mm/s)$', '$|\omega|$ $(1/s)$']
                for img, text in zip(imgs, titles):
                    img.set_xlim([x[0], imsize[1] - x[0]])
                    img.set_ylim([y[0], imsize[0] - y[0]])
                    img.set_xticks([])
                    img.set_yticks([])
                    img.set_title(text)

                    # CALCULATE AND PLOT VELOCITY ALONG CIRCULATION CURVES
                    ax4 = plt.subplot(gs[3])
                    ax5 = plt.subplot(gs[4])
                    ax6 = plt.subplot(gs[5])
                    ax4.set_ylabel('velocity $(mm/s)$')

                    mean_gs = []
                    std_gs = []
                    for r in radii:
                        path_x, path_y = r * cos(phi) + max_x, r * sin(phi) + max_y
                        iux_p = ndimage.map_coordinates(iux, (path_y, path_x), order=1)
                        iuy_p = ndimage.map_coordinates(iuy, (path_y, path_x), order=1)

                        ax4.plot(phi, iux_p, color=cmap(float(r) / float(max(radii))))
                        ax5.plot(phi, iuy_p, color=cmap(float(r) / float(max(radii))))
                        ax6.plot(phi, -iux_p * sin(phi) + iuy_p * cos(phi), color=cmap(float(r) / float(max(radii))))

                        # CALCULATE AND PLOT CIRCULATIONS AND STATISTICS
                        gammas = []
                        ax7 = plt.subplot(gs[6:])
                        for off_i in range(-cm_shift, cm_shift + 1, 10):
                            for off_j in range(-cm_shift, cm_shift + 1, 10):
                                ds = 2 * pi * r / float(NP) * scale
                                path_x, path_y = r * cos(phi) + max_x + off_i, r * sin(phi) + max_y + off_j
                                iux_p = ndimage.map_coordinates(iux, (path_y, path_x), order=1)
                                iuy_p = ndimage.map_coordinates(iuy, (path_y, path_x), order=1)
                                gammas.append(sum((-iux_p * sin(phi) + iuy_p * cos(phi)) * ds))

                        mean_g = mean(asarray(gammas))
                        mean_gs.append(mean_g)
                        std_g = std(asarray(gammas))
                        std_gs.append(std_g)

                        ax7.scatter(r * scale, mean_g, color=cmap(float(r) / float(max(radii))), marker='o')
                        ax7.errorbar(r * scale, mean_g, yerr=std_g, ecolor=cmap(float(r) / float(max(radii))),
                                     elinewidth=2)

                    axs = [ax4, ax5, ax6]
                    titles = ['$u_x$', '$u_y$', r'$u_\theta$']
                    for ax, text in zip(axs, titles):
                        ax.set_title(text)
                        ax.set_xlim([0, 2 * pi])
                        ax.set_ylim([-500, 500])
                        ax.set_xticks((0, pi, 2 * pi))
                        ax.set_xticklabels(('$0$', '$\pi$', '$2\pi$'))

                    # STORE ROBUST AND WEIGHTED AVERAGE CIRCULATION DATA
                    robust_g = mean_gs[argmin(asarray(std_gs))]
                    robust_r = radii[argmin(asarray(std_gs))]
                    weighted_avg = weighted_mean(mean_gs, std_gs)
                    weighted_avg_std = weighted_mean_std(std_gs)

                    ax7.plot([radii[0] * scale, radii[-1] * scale], [weighted_avg, weighted_avg], 'k--')
                    ax7.plot([radii[0] * scale, radii[-1] * scale], [robust_g, robust_g],
                             color=cmap(float(robust_r) / float(max(radii))))
                    ax7.set_ylim([0, 30000])
                    ax7.set_xlabel('countour radius $(mm)$')
                    ax7.set_ylabel('circulation $(mm^2/s)$')
                    ax7.set_title('time: %.4f' % (f / rate))

                    robust_gammas.append(robust_g)
                    robust_radii.append(robust_r)
                    robust_wav_gammas.append(weighted_avg)
                    robust_wav_stds.append(weighted_avg_std)
                    robust_frames.append(f)

                    # STORE CIRCULATION DATA IN JSON FORMAT AND SAVE PLOT
                    circulation_data = {'mean_gamma': list(mean_gs),
                                        'std_gamma': list(std_gs),
                                        'radii': list(radii),
                                        'weighted_avg': weighted_avg,
                                        'weighted_avg_std': weighted_avg_std}

                    # circulation_data_name = 'circulation_data_%06d.json' % f
                    # circulation_data_file = os.path.join(circulation_dir, circulation_data_name)
                    # with open(circulation_data_file, 'w') as fyle:
                    #     json.dump(circulation_data, fyle, sort_keys=True, indent=1, separators=(',', ': '))
                    #     fyle.close()

                fig_name = 'circulation_%06d.png' % f
                fig_file = os.path.join(circulation_dir, fig_name)

                plt.savefig(fig_file)
                plt.close()

                #plt.show()


                        # w_cy, w_cx = ndimage.measurements.center_of_mass(
                #     iomega[max_y - rad:max_y + rad, max_x - rad:max_x + rad])
                # cy = w_cy + (max_y - rad)
                # cx = w_cx + (max_x - rad)
                #
                # # CONFIRM VORTEX CENTER IS IN FRAME
                # if isnan(cx):
                #     print 'VORTEX NOT IN FRAME, SKIPPING'
                #     continue
                #
                # # CONFIRM THAT CIRCULATION CURVES ARE ALL IN THE FRAME
                # bad_y_path = False
                # path_y_limits = radii[-1] * sin(phi) + cy
                # cutoff = (box_size / 2) + 1
                # if (path_y_limits <= cutoff).any() or (path_y_limits >= (imsize[0] - cutoff)).any():
                #     bad_y_path = True
                # if bad_y_path:
                #     print 'CIRCULATION CURVE NOT IN FRAME, SKIPPING'
                #     continue




    print 'Done'