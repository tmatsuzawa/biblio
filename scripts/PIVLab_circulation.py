#!/usr/bin/env python

import argparse
import os
import time
import sys

import cine
import json
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import pickle
from matplotlib import cm
from numpy import *
from scipy import ndimage, interpolate
from mpl_toolkits.axes_grid1 import make_axes_locatable
#import ilpm.cine as cine
import numpy as np

sys.path.append('/Users/stephane/Documents/git/takumi/')
import library.tools.vectools as vec

def load_matlab_data(datapath):
    """Reads data from .txt files generated by PIVlab and places them into numpy arrays

    Parameters
    ----------
    data_loc : str
        The directory containing .txt files generated from PIVlab

    Returns
    -------
    x, y, ux, uy, omega array (floats)
        coordinates, velocity components, and vorticity calculated by PIVlab in easy to use numpy array format
    """
    file = open(datapath)
    x, y, ux, uy, omega = [], [], [], [], []
    for i, line in enumerate(file):
        if i < 3:
            continue
        for j, val in enumerate(line.split(',')):
            if j == 0:
                x.append(int(val))
            elif j == 1:
                y.append(int(val))
            elif j == 2:
                ux.append(float(val))
            elif j == 3:
                uy.append(float(val))
            elif j == 4:
                omega.append(float(val))

    if j==4:
        x, y, ux, uy, omega = map(lambda z: asarray(z), [x, y, ux, uy, omega])
    elif j==3:
        x, y, ux, uy = map(lambda z: asarray(z), [x, y, ux, uy])

    return x, y, ux, uy


def interp_flow_component(x, y, ux, imsize):
    uxindicies = [(yy, xx) for xx, yy in zip(x, y)]
    grid_ind0, grid_ind1 = mgrid[0:imsize[0], 0:imsize[1]]

    griddata = interpolate.griddata(uxindicies, ux, (grid_ind0, grid_ind1), method='linear', fill_value=0.)

    # plt.subplot(111)
    # plt.imshow(griddata)
    # plt.show()
    return griddata


def colorbar(mappable, location='right'):

    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(location, size='5%', pad=0.05)
    return fig.colorbar(mappable, cax=cax)


def weighted_mean(means, stds):
    """
    Compute weighted arithmetic mean
    Parameters
    ----------
    means : list (floats)
        list of mean values
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean : float
    """
    return sum(asarray(means * (1. / asarray(stds)))) / sum(1. / asarray(stds))


def weighted_mean_std(stds):
    """
    Compute the uncertainty for a weighted mean
    Parameters
    ----------
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean_std : float
    """
    return sqrt(1. / sum(1. / asarray(stds)))


if __name__ == '__main__':
    """
    Pass a absolute path of the cine files through '-input' e.g. -input '/absolute/path/to/cineDir/*.cine'
    """
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('-input', metavar='input', type=str, nargs='*', default=None, help='')
    parser.add_argument('-NP', dest='NP', type=int, default=800,
                        help='Number of points to sample along the circulation contour')
    parser.add_argument('-min_radius', dest='min_radius', type=float, default=50,
                        help='Smallest radius of circulation contour explored (pixels)')
    parser.add_argument('-max_radius', dest='max_radius', type=float, default=200,
                        help='Largest radius of circulation contour explored (pixels)')
    parser.add_argument('-sample_pts', dest='sample_pts', type=int, default=10,
                        help='number of points between min and max radius at which to sample the circulation')
    parser.add_argument('-cm_shift', dest='cm_shift', type=int, default=10,
                        help='Largest amount to shift the center of the circulation contour')

    parser.add_argument('-scale', dest='scale', type=float, default=None)
    parser.add_argument('-rate', dest='rate', type=float, default=None)
    parser.add_argument('-frame_spacing', dest='frame_spacing', type=float, default=1)
    parser.add_argument('-plot_spacing', dest='plot_spacing', type=int, default=1)

    parser.add_argument('-start', dest='start', type=int, default=0)
    parser.add_argument('-stop', dest='stop', type=int, default=0)
    parser.add_argument('-skip', dest='skip', type=int, default=10)

    parser.add_argument('-omegabool', dest='omegabool', default=False)


    parser.add_argument('--summarize', dest='summarize', action='store_true', default=False,
                        help='Plot only the aggregate data, assuming that the .json files have already been generated')
    parser.add_argument('--save_circ', dest='save_circ', action='store_true', default=False)


    # PARSE COMMAND LINE INPUTS
    args = parser.parse_args()

    cine_inputs = args.input
    NP = args.NP
    min_radius = args.min_radius
    max_radius = args.max_radius
    sample_pts = args.sample_pts
    cm_shift = args.cm_shift
    summarize = args.summarize
    save_circ = args.save_circ
    scale = args.scale
    rate = args.rate
    frame_spacing = args.frame_spacing
    plot_spacing = args.plot_spacing
    omegabool = args.omegabool

    # SETUP SOME VARIABLES FOR PLOTTING TO BE USED THROUGHOUT SCRIPT
    radii = linspace(min_radius, max_radius, num=sample_pts, endpoint=True)
    phi = arange(NP) * 2 * pi / float(NP)


    for cnum, cine_file in enumerate(cine_inputs):

        # LOAD CINE FILE AND GRAB IMAGE SIZE
        if os.path.isdir(cine_file):
            imsize = (800, 1200)
        else:
            movie = cine.open(cine_file)
            imsize = shape(movie[0])

        box_size = 32

        # GENERATE FILE ARCHITECTURE
        date_dir, cine_name = os.path.split(cine_file)
        name, ext = os.path.splitext(cine_name)
        #cine_dir = os.path.join(date_dir, name)
        resultsdir = date_dir + '/PIV_AnalysisResults/' + name #ABS PATH TO OUTPUT DIRECTORY

        print 'Working on Cine file: ', name

        # # CREATE A DIRECTORY TO STORE RESULTS
        # if not os.path.exists(resultsdir):
        #     os.makedirs(resultsdir)

        # CREATE A DIRECTORY TO STORE RESULTS OF CIRCULATION COMPUTATION
        circulation_dir = resultsdir + '/circulation/'
        if not os.path.exists(circulation_dir):
            os.makedirs(circulation_dir)

        # GRAB A DIRECTORY NAME WHERE PIVLAB-GENERATED txt FILES ARE STORED
        data_dir = date_dir + '/PIV_W%s_step%s_data' % (box_size, int(frame_spacing)) + \
                   '/PIVlab_ratio2_W%spix_Dt_%s_' % (box_size, int(frame_spacing)) + name

        print movie.len

        # CHECK IF DATA FILES(txt FILES GENERATED BY PIVLAB) EXIST
        if not os.path.exists(data_dir):
            print 'NO DATA DIRECTORY FOUND! EXITING'
            sys.exit()


        # INITIALIZE EMTPY LISTS FOR ROBUST GAMMA COMPUTATIONS
        robust_gammas = []
        robust_radii = []
        robust_frames = []
        robust_wav_gammas = []
        robust_wav_stds = []

        # ITERATE THROUGH FRAMES IN CINE FILE
        if args.stop == 0:
            frames = range(args.start, movie.__len__(), args.skip)
        else:
            frames = range(args.start, args.stop, args.skip)
        print 'Working on frame range: (%d:%d)' % (frames[0], frames[-1])

        for i, f in enumerate(frames):
            if f - ((f/plot_spacing) * plot_spacing) == 0:
                print 'Processing frame %d' % f
                try:
                    i += frames[0] / frame_spacing
                except TypeError:
                    print 'NO FRAME SPACING SPECIFIED! EXITING'

                try:
                    data_name = 'D%04d.txt' % (i + 1)
                    print os.path.join(data_dir, data_name)

                    # Load velocity field data from the PIVLab data output
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, data_name))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, data_name))

                except IOError:
                    print 'NO DATA EXISTS FOR FRAME: %d; SKIPPING!' % f
                    continue

                print 'Loaded PIVlab_%d.txt' % (i + 1)
                # COMPUTE INTERPOLATED VELOCITY
                try:
                    iux, iuy = map(lambda flow: interp_flow_component(x, y, flow * scale * rate, imsize), [ux, uy])
                except TypeError:
                    print 'ERROR: No input for scale, rate, or both'
                print iux.shape
                omega = vec.curl(iux,iuy)

                plt.subplot(111)
                plt.imshow(omega)
                plt.show()
                #print len(ux), len(iux), len(uy), len(iuy)
                # COMPUTE VORTICITY USING THE INTERPOLATED VELOCITY FIELD
                #print iux, iuy
                #iomega = interp_flow_component(x, y, omega * rate, imsize)




    print 'Done'